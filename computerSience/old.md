# 목차

- 라이브러리와 프레임워크의 차이점은?
- URL은 뭔가요?
- HTTP/1.1 과 HTTP/2.0의 차이는 뭔가요?
- [쿠키, 세션](#쿠키-세션)
  - 쿠키, 세션을 왜 쓰나요?
  - 쿠키가 뭔가요?
  - 세션이 뭔가요?
  - 쿠키와 세션의 차이는 어떤 점이 있을까요?
- [CORS](#cors)
  - CORS가 뭔가요?
- [Cache](#cache)
- [캐시란 무엇인가요?](#캐시란-무엇인가요)
- [CI CD](#ci-cd)
  - CI CD란 뭔가요?
- [business logic](#business-logic)
  - business logic 이란 무엇인가요?
- [웹팩](#웹팩)
  - 웹팩이란?
  - 모듈이란?
  - 모듈 번들링이란?
  - 웹팩이 등장한 이유 웹팩 사용 시에 이점
  - 바벨이란?
  - 웹팩의 주요 속성 4가지

# 라이브러리와 프레임워크의 차이점은 뭔가요?
라이브러리와 프레임워크의 차이는 제어 흐름에 대한 주도권이 누구 또는 어디에 있는가에 있습니다.  
프레임워크는 전체적인 흐름을 자체적으로 가지고 있으며, 프로그래머는 그 안에 필요한 코드를 작성합니다.(제어의 역전)(Spring, Django, Android 등)  
반면, 라이브러리는 프로그래머가 흐름에 대해 제어를 하며 필요한 상황에 가져다 쓸 수 있습니다.(패키지/모듈)  


# URL은 뭔가요?
URL(Uniform Resource Locators)은 서버에 자원(resource)를 요청하기 위해 입력하는 영문 주소입니다.  
숫자로 되어있는 IP주소보다는 훨씬 기억하기 쉽다는 장점이 있습니다.  
브라우저에서는 이렇게 url로 되어잇는 HTTP요청을 DNS(Domain Name System)를 통해 host에 해당하는 실제 IP주소로 변환하여 서버에 요청(Request)을 보냅니다.  
![image](https://user-images.githubusercontent.com/105098581/223592061-8c73f129-0b84-4f58-8b17-eba5dcc27ba1.png)  

# HTTP/1.1 과 HTTP/2.0의 차이는 뭔가요?
**HTTP/1.1은 기본적으로 커넥션 당 하나의 요청과 응답만 처리한다.**   
즉, 여러 개의 요청을 한 번에 전송할 수 없고 응답 또한 마찬가지이다.  
따라서 HTML 문서 내에 포함된 여러 개의 리소스 요청, 즉 CSS 파일을 로드하는 link 태그, 이미지 파일을 로드하는 img 태그, 자바스크립트를 로드하는 script 태그 등에 의한 리소스 요청이 개별적으로 전송되고 응답 또한 개별적으로 전송된다.  
이처럼 HTTP/1.1은 리소스의 동시 전송이 불가능한 구조이므로 요청할 리소스의 개수에 비례하여 응답 시간도 증가한다는 단점이 있다.  
![image](https://user-images.githubusercontent.com/105098581/223592373-b7a5bcac-bd20-47e1-9d57-48b4390eb58d.png)  
**HTTP/2는 커넥션당 여러 개의 요청과 응답, 즉 다중 요청/응답이 가능하다.**  
여러 리소스의 동시 전송이 가능하므로 HTTP/1.1에 비해 페이지 로드 속도가 약 50% 정도 빠르다고 알려져 있다.  
![image](https://user-images.githubusercontent.com/105098581/223592561-8897297e-61db-4184-9637-d5f39e082ffe.png)  

# 쿠키, 세션

## 쿠키, 세션을 왜 쓰나요?
쿠키와 세션은 HTTP 프로토콜의 무상태성을 보완하기 위해 사용됩니다.  
HTTP 프로토콜은 상태가 없는(stateless) 프로토콜이므로 서버는 클라이언트의 상태를 알 수 없습니다.  
클라이언트의 상태를 알아야 할 경우(예 : 인증) 쿠키와 세션을 사용합니다.

## 쿠키가 뭔가요?
HTTP의 일종으로 사용자가 어떠한 웹 사이트를 방문할 경우, 그 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일입니다.  
HTTP에서 클라이언트의 상태 정보를 클라이언트의 PC에 저장하였다가 필요시 정보를 참조하거나 재사용 할 수 있습니다.
- 쿠키의 특징
  - 이름, 값, 만료일(저장 기간 설정), 경로 정보로 구성되어 있다.
  - 클라이언트에 총 300개의 쿠키를 저장할 수 있다.
  - 하나의 도메인 당 20개의 쿠키를 가질 수 있다.
  - 하나의 쿠키는 4KB(=4096byte)까지 저장 가능하다.
- 쿠키의 동작 순서
    ![image](https://user-images.githubusercontent.com/105098581/223596239-3af5e72d-d6d0-423f-8d83-8cbd0c72c3e7.png)   
    1. 클라이언트가 페이지를 요청한다.(사용자가 웹사이트 접근) 웹 서버는 쿠키를 생성한다.
    2. 생성한 쿠키에 정보를 담아 HTTP 화면을 돌려줄 때, 같이 클라이언트에게 돌려준다.
    3. 넘겨 받은 쿠키는 클라이언트가 가지고 있다가(로컬 PC에 저장)다시 서버에 요청할 때 요청과 함께 쿠키를 전송한다.
    4. 동일 사이트 재방문시 클라이언트의 PC에 해당 쿠키가 있는 경우, 요청 페이지와 함꼐 쿠키를 전송한다.

- 사용 예시
  - 방문했던 사이트에 다시 방문시 아이디와 비밀번호 자동 입력
  - 팝업창을 통해 "오늘 이 창을 다시 보지 않기" 체크

- 쿠키의 약점
  - 쿠키의 특징으로는 클라이언트(브라우저)단에 저장된다는 것이다. 즉, 보안에 취약하다
  - 쿠키를 훔쳐서 계정 접근 권한 등을 탈취해 유저의 정보를 악용할 수 있다.
    ```js
    document.cookie 를 통해 쿠키 스토리지에 저장된 사용자 권한이 있는 쿠키에 접근
    ```
## 세션이 뭔가요?
HTTP 세션이란 클라이언트가 웹 서버에 연결된 순간부터 웹 브라우저를 닫아 서버와의 HTTP 통신을 끝낼 떄 까지의 기간 입니다.  
하지만 보통 세션이라고 말할 떄에는 서버에 세션에 대한 정보(세션 상태, 클라이언트 상태, 세션 데이터 등)를 저장해 놓고 세션 쿠키(고유한 세션 ID값)를 클라이언트에게 주어 서버가 클라이언트를 식별할 수 있도록 하는 방식자체를 의미하는 경우 가 많습니다.  
- 세션의 특징
  - 따로 용량의 제한이 없다(서버의 능력에 따라 다를 수 있다.)
  - 서버에 세션 객체를 생성하며 각 클라이언트 마다 고유한 세션 ID값을 부여한다.
  - 쿠키를 사용하여 세션ID값을 클라이언트에 보낸다
  - 웹 브라우저가 종료되면 세션 쿠키는 삭제된다.

- 세션의 동작 방식
    ![image](https://user-images.githubusercontent.com/105098581/223597041-feaf9f1e-1b2b-47e5-97b0-96ea23e14609.png)
    1. 클라이언트 페이지가 요청한다.
    2. 서버가 클라이언트마다 개별의 세션 ID를 부여한다
    3. 클라이언트는 요청할 때마다 세션 ID를 서버에 전달한다
    4. 서버는 받은 세션ID로 클라이언트 정보를 가져와 활용한다.

## 쿠키와 세션의 차이는 어떤 점이 있을까요?
1. 저장위치
   - 쿠키 : 클라이언트에 파일로 저장
   - 세션 : 서버에 저장 
2. 보안
   - 쿠키 : 클라이언트의 브라우저 로컬에 저장되기 때문에 변질되거나 HTTP request 요청 시에 이를 갈취당할 수 있어서 보안에 취약하다.
   - 세션 : 쿠키를 이용해서 세션id만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적으로 안전하다.
3. 라이프 사이클
   - 쿠키 : 만료시간은 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아있다. 만료기간에 따라 상대적으로 넉넉하게 쿠키를 삭제할 때까지 유지된다.
   - 세션 : 만료기간을 정할 수는 있지만 브라우저가 종료되면 그에 상관없이 삭제된다.
4. 속도
   - 쿠키 : 쿠키에 정보가 있기 때문에 서버에 요청시 속도가 빠르다
   - 세션 : 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느리다
# CORS

## CORS가 뭔가요?
CORS는 Cross Origin Resource Sharing의 약자로, 교차 출처 공유라는 의미입니다.  
Orgin은 scheme, host, port로 이루어진 도메인을 의미합니다. (IE의 경우 port를 비교허지 않음)
```
https://www.naver.com
scheme : https
host : www.naver.com
port : null (공개되지 않음)
```
현재 `자신이 속한 출처(Origin)`를 기준으로 `다른 출처(Origin)`에 API를 요청하게 되면 브라우저에서 이 요청으로 넘어오는 경과가 안전한지 판단하게 됩니다.  
응답을 보내는 출처가 `자신이 속한 출처`가 아닌 `다른 출처`여도 서로 예상되는 출처라면 요청에 대해 허용해주는 응답 해더를 보내, 브라우저가 응답 결과를 보여줍니다.  
이를 CORS(Cross Origin Resource Sharing)이라 합니다.  

### 왜 브라우저가 CORS 요청을 처리하나요?
모든 서버들이 다 CORS를 인지하지는 않기 떄문입니다.  
결과적으로 브라우저는 거부했다고 하더라도, 서버는 처리해버리는 결과가 생길 수 있기 떄문에 서버가 안전하게 요청을 주고받을 수 있도록 브라우저에서 해당 요청(CORS)을 처리합니다.  

### 실제 요청에서는 어떻게 처리하나요?
CORS는 다른 Origin에 대한 요청을 허용하는 정책입니다.   
같은 Origin에서 http 통신을 하는 경우 알아서 cookie가 request header에 들어가지만, 교차 출처로 요청하는 상황에서는 그렇지 않습니다.   
Origin이 다른 http 통신에서는 request header에 쿠키가 자동으로 들어가지 않기 떄문에 서버에게 또는 클라이언트에게 내가 어떤 요청을 보내는 지 알려줄 필요가 있습니다.   
```
프론트 > WithCredentials : true 
서버 > Access-Control-Allow-Credentials : true
```
- WithCredentials 
  - 다른 도메인(Cross Origin)에 요청을 보낼 때 요청에 인증(credential) 정보를 담아서 보낼지를 결정하는 항목입니다.
  - 이 옵션을 사용하면 크로스 도메인 세션 유지가 가능합니다.
- Access-Control-Allow-Credentials
  - 응답 헤더는 요청의 자격증명 모드가 include일 떄 브라우저들이 응답을 프론트엔드 자바스크립트 코드에 노출할지에 대해 알려줍니다.

**express**
```js
const express = require("express");
const cors = require("cors");

const app = express();
const corsOptions = {
    origin : "http://example.com",
    methods: ["GET", "POST"],
    allowedHeaders : ["Content-Type"]
};

app.use(cors(corsOptions));
// 그냥 cors()를 사용하면 모든 cross-origin 요청에 대해 응답합니다.
```

# Cache
캐시(Cache)는 일반적으로 일시적인 특성이 있는 데이터 하위 집합을 저장하는 고속 데이터 스토리지 계층입니다.   
Cache는 프랑스어로 `숨기다`라는 뜻을 가지는 단어인 cacher 에서 파생된 단어로, 물건을 일시적으로 저장, 보관하기 위해 사용하는 곳입니다.  
기술적으로 cache는 자주 필요한 데이터나 값의 복사본을 일시적으로 저장, 보관하기 위해 사용하는 곳입니다.
**처리속도 순서, 메모리 계층 구조**
1. CPU Registers
2. Cache Memory
3. Main Memory (RAM)
4. Secondary Memory

- 상층 구조로 갈수록 빠르고, 비싸고, 작은 용량을 가집니다.
- 또한 CPU와 가까이 위치합니다.
- 캐시 메모리들이 메인 메모리(RAM)보다 빠르지만, 비싸며, 면적 차지 또한 큰 것을 알 수 있습니다.
이러한 메모리 계층 구조의 목적은 캐싱을 이용해 빠르고 작은 메모리와 크고 느린 메모리의 조합을 이용해 크고 빠른 메모리처럼 행동하도록 만들기 위함입니다.  

## Flow
- CPU는 데이터 처리를 위해 메모리와 끊임없이 데이터를 주고받는 구조입니다.
- 메모리가 CPU의 데이터 처리 속도를 쫓아가지 못합니다.
- CPU가 메모리를 기다려야 하는 `병목현상`이 발생합니다.

이 `병목현상`을 완화하기 위해 CPU와 메인 메모리 사이에 크기는 작지만 속도가 빠른 캐시 메모리를 두고,   
캐시 메모리에 향후 재사용할 가능성이 클 것으로 예상되는 데이터의 복사본을 저장해 둔 후 CPU가 요청하는 데이터를 바로바로 전달할 수 있도록 합니다.  
메인 메모리는 DRAM, 캐시 메모리는 SRAM의 구조를 가지는데, SRAM이 셀당 트랜지스터의 개수도 많고 물리적으로 차지하는 면적 또한 훨씬 크다.

# 캐시란 무엇인가요?
```
Caching == Cache + ing
캐시를 사용하는 것을 의미합니다. (Cache의 동사형)
```
- 캐싱
  - 캐시에 데이터나 계산된 결과 값의 복사본을 저장해 둠으로써 전체적인 처리 속도를 향상시킵니다.
  - 데이터에 직접적으로 접근하는 데 걸리는 시간이 오래 걸릴 때 사용합니다
  - 필요한 값을 얻기 위해 계산하는 과정을 생략하고 싶을 떄 사용합니다
  - 반복적으로 동일한 결과를 돌려주는 경우(이미지,썸네일 등) 사용합니다.

캐싱은 복사본을 이용하는 것입니다.

# CI CD

## CI CD란 뭔가요?

CI/CD는 애플리케이션 개발 단계를 자동화하여 애플리케이션을 보다 짧은 주기로 고객에게 제공하는 방법입니다.  
`CI`는 개발자를 위한 자동화 프로세스인 지속적인 통합 `Continous Integration`을 의미합니다.  
`CD`는 지속적인 서비스 제공 `Continous Delivery`및 지속적인 배포 `Continous Deployment`를 의미합니다.   

# business logic

## business logic 이란 무엇인가요?
비즈니스 로직(Business logic)은 컴퓨터 프로그램에서 실세계의 규칙에 따라 데이터를 생성,표시,저장,변경하는 부분을 일컫는다. 이 용어는 특히 데이터베이스, 표시장치 등 프로그램의 다른 부분과 대조되는 개념으로 쓰인다.  
- 비즈니스 로직(도메인 로직/ 애플리케이션 로직)이란 프로그램의 핵심 로직을 뜻합니다.
- 어떻게 데이터가 생성되고 저장되고 수정되는지를 정의한 것이 비즈니스 로직이라고 할 수 있습니다.
- 만약 쇼핑몰 프로그램을 사용한다고 했을 때 물품 목록을 보고 마음에 드는 물품들을 장바구니에 담을 것입니다.
- 이 때 장바구니에 물품을 추가할 때마다 결제예정 금액이 추가된 물품의 금액에 맞게 변경되는 것을 보신 적이 있으실 겁니다.
- 이렇게 장바구니에 있는 결제예정 금액이 물품이 추가됨에 따라 수정되는 로직이 바로 비즈니스 로직입니다.

# 웹팩

## 웹팩이란?
웹팩이란 최신 프론트엔드 프레임워크에서 가장 많이 사용되는 모듈 번들러(Module Bundler)입니다.  
모듈 번들러란 웹 애플리케이션을 구성하는 자원(HTML, CSS, JavaScrpit, Images 등)을 모두 각각의 모듈로 보고 이를 조합해서 병합된 하나의 결과물을 만드는 도구를 의미합니다.  

## 모듈이란?
모듈이란 프로그래밍 관점에서 특정 기능을 갖는 작은 코드 단위를 의미합니다.  
## 모듈 번들링이란?
아래 그림과 같이 웹 애플리케이션을 구성하는 몇십, 몇백개의 자원들을 하나의 파일로 병합 및 압축해주는 동작을 모듈 번들링이라고 합니다.  
파일들의 연관된 관계를 파악하여 파일들을 하나의 파일로 압축시켜주는 과정을 번들링 과정이라 합니다.  
![image](https://user-images.githubusercontent.com/105098581/223638077-7d75d57d-1d42-4a49-a5d9-72b1a27254aa.png)

## 웹팩이 등장한 이유 웹팩 사용 시에 이점
1. 파일 단위의 자바스크립트 모듈 관리의 필요성
2. 웹 개발 작업 자동화 도구
3. 웹 애플리케이션의 빠른 로딩 속도와 높은 성능
## 바벨이란?
바벨은 자바스크립트에서 지원하는 최신 문법(ES6, ES7, ES8, ES9, ...)들을 최대한 많은 브라우저 환경에서 호환이 가능하도록 변환해주는(트랜스파일링 해주는)언어입니다.  
- 트랜스 파일
  - 한 언어로 작성된 소스 코드를 비슷한 수준의 추상화를 가진 다른 언어로 변환하는 것을 말합니다.
  - es6 code -> es5 code
  - c++ -> c

- 바벨 변환
  - 바벨을 사용하면 거대한 변화가 생기기 시작한 기점인 ES6 이후의 문법을 브라우저에서 범용적으로 사용되는 문법 단계로 변환해줄 수 있습니다.

```js
// Babel Input : ES2015 arrow function
[1,2,3].map((n)=> n + 1);

// Babel Output : ES5 equivalent
[1,2,3].map(function (n){
    return n + 1 ;
})
```

## 웹팩의 주요 속성 4가지
1. entry
2. output
3. loader
4. plugin

### entry
entry 속성은 웹팩에서 웹 자원을 변환하기 위해 필요한 최초 진입점이자 자바스크립트 파일 경로입니다.  
`빌드를 할 대상 파일의 위치`라고 볼 수 있습니다.  
```js
// webpack.config.js
module.exports = {
    entry: "./src/index.js"
};
```
entry 속성에 지정된 파일에는 웹 애플리케이션의 전반적인 구조와 내용이 담겨져 있어야 합니다.  
웹팩이 해당 파일을 가지고 웹 애플리케이션에서 사용되는 모듈들간의 연관 관계를 이해하고 분석하기 때문에 애플리케이션을 동작시킬 수 있는 내용들이 담겨져 있어야 합니다.   
![image](https://user-images.githubusercontent.com/105098581/223640055-f561b36f-4ed3-4cf5-a0c1-cff3a23e3fec.png)  
위의 이미지 예시로 사용자의 로그인화면, 메인 화면, 게시글 작성화면 등 웹서비스에 필요한 화면들이 모두 index.js 파일에서 불려져 사용되고 있기 때문에 웹팩을 실행하면 해당 파일들의 내용까지 해석하여 파일을 빌드해줄 것입니다.  

#### options
하지만 entry의 경우 엔트리 포인트가 1개가 될 수도 있지만 아래와 같이 여러 개가 될 수도 있습니다.  
```js
entry : {
    login : './src/LoginView.js',
    main: './src/MainView.js'
}
```
위와 같이 엔트리 포인트를 분리하는 경우는 싱글 페이지 애플리케이션이 아닌 특정 페이지로 진입했을 때 서버에서 해당 정보를 내려주는 형태의 멀티 페이지 애플리케이션에 적합합니다.  

### output
output 속성은 웹팩을 돌리고 난 결과물의 파일 경로를 의미합니다.
```js
// webpack.config.js
module.exports = {
    output: {
        filename: "bundle.js"
    },
}
```
앞에서 배운 entry 속성과는 다르게 객체 형태로 옵션들을 추가해야 합니다.  
최소한 filename은 지정해줘야 하며 일반적으로 아래와 같이 path 속성을 함께 정의합니다.  
```js
// webpack.config.js
var path = require("path");

module.exports = {
    output : {
        filename: "bundle.js",
        path: path.resolve(__dirname, "./dist"),
    },
};
```
- filename 속성은 웹팩으로 빌드(번들링)한 파일의 이름을 의미합니다.
- path 속성은 해당 파일의 경로를 의미합니다.
- path 속성에서 사용된 path.resolve() 코드는 인자로 넘어온 경로들을 조합하여 유효한 파일 경로를 만들어주는 Node.js API입니다.

따라서 dist 라는 폴더 안에 있는 bundle.js라는 파일 이름으로 엔트리에 들어온 파일을 빌드(번들링)하여 결과물로 가져올 것입니다.  

#### options
앞에서 살펴본 filename 속성에 여러 가지 옵션을 넣을 수 있습니다.
1. 결과 파일 이름에 entry 속성을 포함하는 옵션
```js
module.exports = {
    output: {
        filename: "[name].bundle.js"
    }
}
```
2. 결과 파일 이름에 웹팩 내부적으로 사용하는 모듈ID 를 포함하는 옵션

```js
module.exports = {
    output: {
        filename: "[id].bundle.js"
    }
}
```

### loader
로더(Loader)는 웹팩이 웹 애플리케이션을 해석할 때 자바스크립트 파일이 아닌 웹 자원(HTML, CSS, Images, 폰트 등)들을 빌드 시에, 자바스크립트의 output(산출물) 파일에 포함될 수 있도록 도와주는 속성입니다.  
```js
// webpack.config.js
module.exports = {
    module: {
        rules: [],
    }
}
```
엔트리나 아웃풋 속성과는 다르게 module이라는 이름을 사용합니다.  
#### loader가 없는 경우
로더는 앞서 말한대로 js 이외 형식의 파일들을 빌드할 떄 추가하는 속성이라고 볼 수 있습니다.  
만약 Js파일 내에 Css 파일이 import 된 상황에서 Loader 가 없다면 어떻게 될까?  
```js
📁 index.js
import "./base.css";
```
빌드를 한다면 다음과 같은 에러를 볼 수 있습니다.   
![image](https://user-images.githubusercontent.com/105098581/223642623-2557e9ee-d781-4b0a-b992-e56cd2c71319.png)   
빌드 시에, 엔트리로 설정한 index.js 파일 내에 웹팩이 알아볼 수 없는 파일 형식자인 css가 포함되어서 이를 해석할 수 없다는 에러를 발생시켰습니다.  
위와 같이 원래 목적인 js를 변환하는 것이 아니라면 loader를 통해 같이 빌드할 수 있는 여건을 만들어 줘야 합니다.  

```js
📁 webpack.config.js

var path = require("path");

module.exports = {
  mode: "none", // production, development, none >> 배포 시에는 production으로 설정해야 한다
  entry: "./index.js",
  output: {
    filename: "bundle.js",
    path: path.resolve(__dirname, "dist"),
  },
  module: {
    rules: [
      {
        // 'test'는 확장자를 의미한다
        test: /\.css$/,
        // 'use'는 해당 파일들을 어떤 방향으로 로딩하는지 설정해주는 것이다

        // css-loader는 웹팩 안에 css 파일을 같이 번들링할 수 있도록 만드는 용도이다
        // style-loader는 해당 css를 html 파일 내에 인라인 코드로 실제 스타일에 적용하는 용도로 사용된다

        // 🔥 순서(오른쪽 to 왼쪽으로 적용) 또한 영향이 있으니, 먼저 적용되야 하는 로더를 오른쪽에 작성해야 한다
        use: ["style-loader", "css-loader"],
      },
      // 만든 바벨 로더 예시
      // {
      //   test: /\.js$/, test > 확장자
      //   use: ["babel-loader"], use > 사용할 라이브러리
      // },
    ],
  },
};
```

### plugin
우리가 설정한 output인 bundle.js에 css 파일을 같이 번들링하는 것이 아닌 별도의 css 파일로 만들어주기 위해서는 플러그인을 사용할 필요가 있습니다.   
플러그인(plugin)은 웹팩의 기본적인 동작에 추가적인 기능을 제공하는 속성입니다.  
로더와 피교하면 로더는 파일을 해석하고 변환하는 과정에 관여하는 반면, 플러그인은 해당 결과물의 형태를 바꾸는 역할을 한다고 보면 됩니다.  
```js
// webpack.config.js
module.exports = {
    plugins : [],
};
```
플로그인의 배열에는 생성자 함수로 생성한 객체 인스턴스만 추가될 수 있습니다.  
```js
// webpack.config.js
var webpack = require("webpack");
var HtmlWebpackPlugin = require("html-webpack-plugin");

module.exports = {
    plugins : [new HtmlWebpackPlugin(), new webpack.ProgressPlugin()],
}
```
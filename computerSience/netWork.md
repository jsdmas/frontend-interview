# 목차

- 웹 프로토콜이 뭔가요?
- ⭐️HTTP가 뭔가요?
  - ⭐️HTTP의 GET,POST를 비교 설명해주세요
  - HTTP의 PUT,PATCH를 비교 설명해주세요
  - ⭐️ HTTP의 Status Code를 설명해주세요
  - ⭐️ HTTP와 HTTPS의 차이점이 뭔가요?
  - HTTPS의 동작에 대해서 설명해주세요
- TCP와 UDP를 설명해주세요
- TCP의 3-Way-HandShake와 4-Way-HandShake에 대해 설명해주세요

# 웹 프로토콜(Web Protocol)

> 인터넷 상에서 정보를 주고받는데 사용하는 통신 규약(protocol)입니다.

대표적인 웹 프로토콜로는 HTTP(Hyper Text Transfer Protocol)이 있습니다.

# ⭐️ HTTP

> 브라우저가 웹 서버와 통신하기 위해 사용하는 프로토콜입니다. 80번 포트를 사용하여 통신합니다.

대표적인 요청의 종류는 GET, POST, DELETE, PUT 등이 있습니다.
HTTP 특징으로는 아래와 같습니다.
- 비-연결 지향(Connectionless)
  - 연결을 유지하게 되면 서버에 많은 부담을 줄 수 있습니다.
- 무상태성(Stateless)
  - 각각의 요청이 독립적으로 여겨지는 특징으로 서버는 클라이언트의 상태를 유지하지 않습니다.
  - 이를 해결하기 위해 쿠키, 세션등의 방식이 사용됩니다.

## ⭐️ GET, POST 비교 설명

### GET
> 서버에게 조회할 리소스를 요청합니다.

데이터가 `HTTP Request Message`의 **Header 부분에 url** 이 담겨서 전송됩니다.  
때문에 url상에 `?`뒤에 데이터가 붙어 request를 보내게 되는 것입니다.  
이런 방식은 url이라는 공간에 담겨가기 떄문에 전송할 수 있는 데이터 크기가 제한적입니다.  
보안이 필요한 데이터(ex: password)는 url에 그대로 노출되므로 `GET`방식으로는 적절하지 않습니다.  

### POST
> 서버에게 본문(body)에 생성할 데이터를 삽입하여 전송합니다.

POST 방식의 request는 `HTTP Request Message`의 **Body** 부분에 데이터가 담겨서 전송됩니다.  
떄문에 GET방식보다 데이터 크기가 크고 보안면에서 더 좋습니다.  

### 더 많은 차이점
GET 서버에서 어떤 데이터를 가져와서 보여주는 역할이며 서버값이나 상태등을 변경하지 않습니다.  
반면 POST는 서버의 값이나 상태를 변경&추가 하기위해 사용합니다.  


## PUT, PATCH 비교 설명

둘다 리소스의 업데이트를 위해 사용되는 메서드지만 차이점이 존재합니다.

### PUT
> 전체 리소스를 수정할떄 사용하며 리소스가 존재하지 않을시 새로운 리소스를 생성합니다.

```
PUT /resource/path HTTP/1.1
Host: example.com
Content-Type: application/json
Content-Length: 25

{"updated": "data field"}
```

### PATCH
> 일부 리소스를 수정할떄 사용하며 리소스가 존재하지 않을시 새로운 리소스를 생성하지 않습니다.

```
PATCH /resource/path HTTP/1.1
Host: example.com
Content-Type: application/json-patch+json
Content-Length: 49

[
  { "op": "replace", "path": "/field1", "value": "new value" },
  { "op": "add", "path": "/field2", "value": "value2" }
]
```

## ⭐️ HTTP의 Status Code 설명
> 서버가 클라이언트의 요청에 응답할 떄 응답 상태를 나타내는 숫자로 구성된 코드입니다.
개발자가 통신 상태를 파악하고 적절한 처리를 수행하는 데 도움을 줍니다.

1. 1xx (Informational): 요청이 수신되었으며 처리 중입니다.
2. 2xx (Success): 요청이 성공적으로 처리되었습니다.
3. 4xx (Client Error): 클라이언트의 요청에 오류가 있습니다.
4. 5xx (Server Error): 서버에서 요청을 처리하는 동안 오류가 발생했습니다.

## ⭐️ HTTP와 HTTPS의 차이점

HTTP는 기본적으로 암호화되지 않은 텍스트 데이터를 전송합니다.  
HTTPS는 SSL/TLS 프로토콜을 이용해 데이터를 암호화하여 전송합니다.  

- 공개키(publick Key), 비밀키(Private Key) : 공개키는 모두가 볼 수 있는 키이며 비밀키는 소유자만이 가지고 있는 키로 암/복호화에 사용됩니다.
- 대칭키 암호화 : 서버, 클라이언트가 암/복호화에 동일한 비밀키를 사용하는 방식입니다.
- 비대칭키 암호화 : 서버, 클라이언트가 암/복호화에 각각 다른 비밀키를 사용하는 방식으로 공개키를 통해 암호화를 하고 비밀키를 통해 복호화를 합니다.
- 인증기관(CA: Certificate Authority) : 클라이언트가 접속을 요청한 서버가 의도한 서버가 맞는지 인증해주는 역할을 하는 보증된 기업들입니다.
  - 클라이언트는 서버에 요청을해 CA에서 발급한 인증서를 받은 뒤 CA의 공개키로 복호화하여 신뢰할 만한 인증서인지 검증합니다.
  - CA의 공개키로 복호화되는 암호화는 오직 CA의 비밀키로 암호화한 경우밖에 없기 때문에 복호화되면 신뢰할 만한 것입니다.

## HTTPS의 동작에 대해 설명해주세요
HTTPS는 **대칭키 암호화**를 사용하며 다음과 같은 과정을 거칩니다.
1. 클라이언트가 서버에게 접속요청을 하면 서버는 CA에서 발급받은 인증서를 보냅니다. (인증서에는 CA의 비밀키로 암호화된 사이트정보와 공개키가 들어있습니다.)
2. 클라이언트는 인증서를 받아 CA의 공개키로 복호화하여 접속요청한 서버가 신뢰할만한지 검증합니다.
3. 복호화 되면 인증서가 신뢰할 만하기 때문에 데이터를 주고받을 대칭키를 생성합니다.
4. 대칭키를 서버의 공개키로 암호화하여 서버에게 전송합니다.
5. 서버는 자신의 비밀키로 클라이언트가 보낸 대칭키를 복호화한 뒤 그 대칭키를 통해 데이터를 주고받습니다.

# TCP와 UDP를 설명해주세요

> OSI 7계층에서 전송계층(Transport layer)에 속하는 데이터 전송 프로토콜입니다.

**TCP(Transmission Control Protocol)**  
데이터가 반드시 전달되는 것을 보장하는 프로토콜로 다음과 같은 특징들을 같고 이를 통해 신뢰성을 보장받습니다.  
- 연결지향(Connection-oriented)으로 2개의 호스트가 통신을 하기 전 연결이 이루어져야 합니다.
- 높은 신뢰성(Reliability)과 순서대로 전송하는 것(In-order delivery)을 보장합니다.
  - 흐름 제어(Flow Control)를 통해 송신자의 데이터 양을 조절합니다.
  - 혼잡 제어(Congestion Control)를 통해 네트워크 상황을 감지하고 송신자의 데이터 양을 조절합니다.
  - 에러 감지(Error detection)를 통해 잘못 전송되었을 경우 재전송 합니다.
- 전 이중(Full duplex)방식 으로 두 호스트 모두 송신자와 수신자가 될 수 있습니다.
- 바이트 스트림(Byte stream)을 사용하여 데이터를 연속적인 바이트로 보고, 세그먼트(Segment)라는 단위의 패킷으로 쪼개서 보냅니다.
- HTTP, FTP, SMTP 등에서 사용됩니다.

**UDP(User Datagram Protocol)**  
TCP와는 다르게 신뢰성을 보장하지 않는 프로토콜로 다음 특징을 같습니다.
- 비연결형(Connection-less) 으로 연결을 설정하고 해제하는 과정이 없습니다.
- 신뢰성이 없고 전송되는 데이터의 순서를 보장하지 않습니다.
  - 흐름제어, 혼잡제어가 없습니다
  - 에러감지는 헤더의 체크섬(Checksum)을 이용한 정도밖에 없습니다.
- 패킷의 단위가 데이터그램(Datagram)으로 경계가 분명 하여 수신자는 송신자가 보낸 그대로의 크기로 받게 됩니다.
- 서버와 클라이언트는 유니캐스트(1:1), 브로드캐스트(1:N), 멀티캐스트(1:M)가 가능합니다.
- TCP에 비해 하는 작업들이 적기 떄문에 속도가 빠릅니다.
- DNS, DHCP, 비디오/오디오 스트리밍 등에 사용됩니다.

# TCP의 3-Way-handShake, 4-Way-handShake에 대해 설명해주세요

## 3-Way-handShake
TCP가 호스트간의 연결을 설정하는 방법으로 SYN/ACK 패킷을 통해 이루어집니다. SYN패킷은 동기화(SYNchronize)를 의미하는 패킷이며, ACK 패킷은 확인 (ACKnowledgement)을 의미하는 패킷입니다.  
![3-way-handshake](https://github.com/jsdmas/jsdmas.github.io/assets/105098581/1a5b0635-d782-40c5-8690-cb9b33100928)

- SYN_SENT : 클라이언트가 능동적으로 서버에게 연결요청을 하자고 시퀀스 번호를 생성하여 SYN패킷에 담아 보냅니다.(능동 개방)
- LISTEN : 서버가 클라이언트 요청을 기다리고 있습니다.
- SYN_RECEIVED : SYN패킷을 받은 서버는 자신만의 시퀀스 번호를 생성하여 SYN패킷에 담고 클라이언트의 SYN 패킷에 있는 시퀀스 번호에 1을 더해서 ACK패킷에 담아 보냅니다.
- 클라이언트 ESTABLISHED : SYN+ACK 패킷을 받은 클라이언트는 ACK패킷의 시퀀스 번호를 보고 자신이 보낸 시퀀스 번호와 차이가 1임을 확인합니다.
  - 차이가 1이라면 제대로 연결되어 있다고 판단하고 서버의 SYN 패킷에 있는 시퀀스 번호에 1을 더해 ACK패킷에 담아 보냅니다.
- 서버 ESTABLISHED : 클라이언트의 ACK 패킷을 받고 그 안의 시퀀스 번호가 보냈던 SYN 패킷의 시퀀스 번호 +1이라면 연결이 완료되었다고 판단합니다. 이후부터 본격적인 통신을 할 수 있게 됩니다.



## 4-Way-handShake

3-way-handShake가 TCP 연결을 초기화 할때 사용되었다면  
4-way-handShake는 세션을 종료하기 위해 수행되는 절차입니다.  


![image](https://github.com/jsdmas/jsdmas.github.io/assets/105098581/d4a8fc5e-2b14-41d4-be2b-49b98a6d1cd7)

1. 클라이언트가 연결을 종료하겠다는 FIN플래그를 전송합니다. 이떄 클라이언트는 **FIN-WAIT**상태가 됩니다.
2. 서버는 FIN플래그를 받고 일단 확인메세지 ACK를 보내고 자신의 통신이 끝날때까지 기다리는데 이 상태가 서버의 **CLOSE-WAIT**상태입니다.
3. 연결을 종료할 준비가 되면, 연결 해지를 위한 준비가 되었음을 알리기 위해 클라이언트에게 FIN플래그를 전송합니다. 이떄 서버의 상태는 **LAST-ACK**입니다.
4. 클라이언트는 해지준비가 되었다는 ACK를 확인했다는 메시지를 보냅니다. 클라이언트는 상태가 **FIN-WAIT 에서 TIME-WAIT**로 변경됩니다.
